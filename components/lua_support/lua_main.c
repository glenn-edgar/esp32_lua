
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <esp_types.h>
\
#include "watchdog.h"
#include "lprefix.h"
#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"
#include "msgpack_rx_handler.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "mqtt_ctrl.h"
#include "lua_cmsgpack.h"
#include "lua_freertos.h"
#include "lua_watchdog.h"
#include "lua_main.h"

#define LUA_TASK_NUMBER 10
#define LUA_FILE_SIZE   32



static uint32_t lua_task_number;
static char      lua_file_names[LUA_TASK_NUMBER][LUA_FILE_SIZE];
static char      lua_task_names[LUA_TASK_NUMBER][LUA_FILE_SIZE];

//static void allocate_string_memory(void);
static void lua_task_shell (void *file_name); 
static bool lua_read_file_configurations(void  );
static bool find_lua_task_names( cmp_ctx_t     *ctx ,uint32_t data_len, char* data );
static bool process_array_buffer(uint32_t index,uint32_t data_len , char *data);
static int dofile (lua_State *L, const char *name);
#if 0
static int dostring (lua_State *L, const char *s, const char *name);
#endif
void lua_initialize_main(void)
{
     lua_task_number = LUA_TASK_NUMBER;
    
    if( lua_read_file_configurations() == true)
    {
       task_wait_for_mqtt_connection();
       //allocate_string_memory();
       for(int i = 0; i< lua_task_number;i++)
       {         
          xTaskCreate(lua_task_shell, lua_task_names[i], 4000, lua_file_names[i], 40, NULL);
       }
       
    }
   

    
}
#if 0
static void allocate_string_memory(void)
{
    char *temp;    
    for(int i = 0; i < LUA_TASK_NUMBER  ;i++)
    {
        temp   = malloc(LUA_FILE_SIZE+2);
        if(temp == NULL){ abort();}// out of memory
        lua_file_names[i ] = temp;
        temp   = malloc(LUA_FILE_SIZE+2);
        if(temp == NULL){ abort();}// out of memory
        lua_task_names[i ] = temp;
        
       
    }
   
}
#endif
static void lua_task_shell(void *input) 
{
   
  char *file_name;
  TaskHandle_t current_task_handle;
  lua_State *L;
  
  
  
  file_name = (char *)input;
  printf("lua file name is %s \n",file_name);
  L = luaL_newstate();  /* create state */
  
  if (L == NULL) 
  {
     abort();
  }

  lua_pushboolean(L, 1);  /* signal for libraries to ignore env. vars. */
  lua_setfield(L, LUA_REGISTRYINDEX, "LUA_NOENV");

  luaL_openlibs(L);  /* open standard libraries */
  printf("openning message pack extension %d \n",luaopen_cmsgpack(L));
  
  /*
  **
  ** open other libraries
  **
  */
  free_rtos_create_queue();  
  printf("openning freertos extension %d \n",luaopen_freertos(L));
  printf("openning lua watchdog externsion %d \n",luaopen_watchdog(L));
  

  dofile(L, file_name);   
  printf("closing lua file \n");
  
  lua_close(L);
  current_task_handle =  xTaskGetCurrentTaskHandle( );
  vTaskDelete( current_task_handle);
}

/*
** Message handler used to run all chunks
*/
static int msghandler (lua_State *L) {
  const char *msg = lua_tostring(L, 1);
  if (msg == NULL) {  /* is error object not a string? */
    if (luaL_callmeta(L, 1, "__tostring") &&  /* does it have a metamethod */
        lua_type(L, -1) == LUA_TSTRING)  /* that produces a string? */
      return 1;  /* that is the message */
    else
      msg = lua_pushfstring(L, "(error object is a %s value)",
                               luaL_typename(L, 1));
  }
  luaL_traceback(L, L, msg, 1);  /* append a standard traceback */
  return 1;  /* return the traceback */
}

/*
** Interface to 'lua_pcall', which sets appropriate message function
** and C-signal handler. Used to run all chunks.
*/
static int docall (lua_State *L, int narg, int nres) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, msghandler);  /* push message handler */
  lua_insert(L, base);  /* put it under function and args */

  status = lua_pcall(L, narg, nres, base);
  
  lua_remove(L, base);  /* remove message handler from the stack */
  return status;
}

/*
** Prints an error message, adding the program name in front of it
** (if present)
*/
static void l_message (const char *msg) {
  
  lua_writestringerror("%s\n", msg);
}


/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int report (lua_State *L, int status) {
  if (status != LUA_OK) {
    const char *msg = lua_tostring(L, -1);
    l_message( msg);
    lua_pop(L, 1);  /* remove message */
  }
  return status;
}

static int dochunk (lua_State *L, int status) {
  if (status == LUA_OK) status = docall(L, 0, 0);
  return report(L, status);
}


static int dofile (lua_State *L, const char *name) {
  return dochunk(L, luaL_loadfile(L, name));
}

#if 0
static int dostring (lua_State *L, const char *s, const char *name) {
  return dochunk(L, luaL_loadbuffer(L, s, strlen(s), name));
}
#endif




static bool lua_read_file_configurations( void )
{
    bool          return_value;
    cmp_ctx_t     ctx;
    char          *buffer;
    uint32_t      buffer_size = 1000;
    
       
    
    if( msgpack_rx_handler_file(&ctx,"/spiffs/LUA_TASKS.LUA" ,  &buffer,&buffer_size ) != true)
    {
        
         return false;
    }
   
    

    return_value = find_lua_task_names(&ctx, buffer_size, buffer );       
    //printf("return_value %d ^^^^^^^^^^^^^^^^^^^^^^^\n",return_value);    
    
    free(buffer);
    return return_value;    
    
}
/*
**
** MESSAGE PACK STUFF
**
**
*/
static bool find_lua_task_names( cmp_ctx_t     *ctx ,uint32_t data_len, char* data )
{      
    uint32_t      binary_length[ LUA_TASK_NUMBER ];
    char          *binary_buffer[ LUA_TASK_NUMBER];
    
    
    
    
    if( msgpack_rx_handler_find_array_count(ctx,"LUA_TASKS",&lua_task_number) != true )
    {
        //printf("lua tasks not found *************************\n");
        return false;
    }
    //printf("lua task number %d *********************************\n",lua_task_number);
    if(lua_task_number >= LUA_TASK_NUMBER){ return false; }
    
    
   
    if(msgpack_rx_handler_get_binary_array(ctx,"LUA_TASKS",&lua_task_number,binary_length,binary_buffer) == false)
    {
       
        return false;
    }
    //printf("lua task chunks found \n");
    for(int i = 0; i< lua_task_number ;i++)
    {
       
       if( process_array_buffer(i, binary_length[i],binary_buffer[i]) == false)
       {
           
           return false;
       }
       
    }

  
    return true;       
    
    
}


static bool process_array_buffer( uint32_t index,uint32_t data_len , char *data)
{
   
 
   cmp_ctx_t     ctx;
   uint32_t      size;
   
   
   msgpack_rx_handler_init(&ctx, data, data_len);
   
   size = LUA_FILE_SIZE;
   if( msgpack_rx_handler_find_string(&ctx,"LUA_TASK_NAME", lua_task_names[index],&size ) == false)
   {
       return false;
       
   }  
   printf("found lua file name %s \n",lua_task_names[index]);
   size = LUA_FILE_SIZE; 
   if( msgpack_rx_handler_find_string(&ctx,"LUA_TASK_FILE", lua_file_names[index],&size )== false)
   {
       return false;
       
   }   
   printf("found lua task name %s \n",lua_file_names[index]);
 

    
   return true;
    
}
